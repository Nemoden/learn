- [2025-11-23] `aws sts get-caller-identity` returns your AWS identity info (Account ID, UserId, ARN) - useful for verifying which AWS credentials/profile you're currently using
- [2025-11-23] SAM CLI (`aws-sam-cli`) is a separate tool from AWS CLI - it's AWS's framework for building/deploying serverless apps with Infrastructure as Code (compiles to CloudFormation). Install via `brew install aws-sam-cli` or add to Nix flake
- [2025-11-23] To configure AWS credentials for a specific profile, use `aws configure --profile <profile-name>` — without `--profile`, it overwrites the `default` profile. Credentials stored in `~/.aws/credentials`, each profile has its own Access Key ID and Secret Access Key
- [2025-11-23] SAM local Lambda runs in Docker containers but can't reach localhost services directly — use `host.docker.internal` as the hostname in endpoint URLs (e.g., `http://host.docker.internal:8000` for DynamoDB Local). Pass endpoints via `--env-vars env.json`, then use `endpoint_url=os.getenv('DYNAMODB_ENDPOINT')` in boto3 client/resource calls
- [2025-11-23] `sam deploy` requires an S3 bucket to upload packaged Lambda code/dependencies before deploying — use `sam deploy --guided` on first deploy to configure bucket (saved to `samconfig.toml`), or specify `--s3-bucket <bucket-name>` manually. SAM automatically creates deployment artifacts and uploads to S3 during deploy
- [2025-11-23] `sam build` creates `.aws-sam/` directory containing built Lambda artifacts (dependencies, compiled code) — add this to `.gitignore` as it's generated output that shouldn't be committed to version control
- [2025-11-23] SAM deploys to the AWS region from your CLI configuration (check with `aws configure get region --profile <profile-name>`) — override with `sam deploy --region <region>` or set in `samconfig.toml`. All resources (Lambda, API Gateway, etc.) are created in this region
- [2025-11-23] `sam deploy --guided` prompts for configuration (stack name, region, S3 bucket, etc.) and saves choices to `samconfig.toml` — subsequent `sam deploy` commands read from this file automatically, so you don't need to specify parameters again. Commit `samconfig.toml` to git for team consistency
- [2025-11-23] SAM automatically creates all required infrastructure: when you define an `AWS::Serverless::Function` with API events, `sam deploy` creates the Lambda function, API Gateway REST API, execution IAM role with CloudWatch Logs permissions, and CloudWatch log group — you don't manually create these supporting resources
- [2025-11-23] SAM templates can mix SAM-specific resources (`AWS::Serverless::Function`, `AWS::Serverless::Api`, etc.) with standard CloudFormation resources (`AWS::S3::Bucket`, `AWS::DynamoDB::Table`, etc.) in the same `template.yaml` — SAM is syntactic sugar on top of CloudFormation, not a replacement. Use SAM resources for serverless components, CFN resources for everything else
- [2025-11-24] CloudFormation's `DeletionPolicy: Retain` only protects resources when you delete the stack, not during drift correction — manual changes still get overwritten on next deploy
- [2025-11-25] `sam build --use-container` runs the build inside a Docker container with Python + pip pre-configured (AWS provides official runtime images) — use when local Python environment lacks pip or has dependency conflicts. This mirrors Lambda's actual execution environment more closely than local builds
- [2025-11-25] `samconfig.toml` can have multiple named configuration sections (e.g., `[default]`, `[production]`) — `sam deploy` uses `[default]` by default, use `sam deploy --config-env production` to deploy with a different configuration section. Each section can have different stack names, regions, and deployment parameters
- [2025-11-25] SAM automatically creates a managed S3 bucket for deployment artifacts (Lambda code packages, CloudFormation templates) — you can specify a different bucket in `samconfig.toml` or set `resolve_s3=False` to disable automatic bucket creation and use a manually specified bucket instead
- [2025-11-25] IaC tools (SAM, Terraform, CDK) often need permanent credentials or explicit session handling (temporary/SSO credentials can cause "unable to locate credentials" errors) — production solutions: CI/CD pipelines using IAM roles (no keys needed), AWS SSO with proper SDK configuration, or short-lived credentials via STS assume-role
- [2025-11-25] Lambda has two distinct permission types: (1) **Execution Role (IAM Role)** — defines what Lambda can do (access S3, DynamoDB, SES, etc.), created as `HelloWorldFunctionRole`; (2) **Invoke Permission (Lambda Permission)** — defines who can call Lambda (API Gateway, S3 events, CLI, etc.), created as resource-based policy like `HelloWorldPermissionProd`. Execution role = Lambda's capabilities, Invoke permission = Lambda's callers
- [2025-11-25] Lambda has a 512MB ephemeral disk limit (`/tmp` directory) and storage is destroyed after execution — for persistent file storage, use S3 instead. Lambda is designed for compute, not storage
- [2025-11-25] API Gateway has a 10MB payload limit — you can't upload large files through API Gateway/Lambda. Solution: use S3 presigned URLs where client uploads directly to S3, bypassing API Gateway entirely
- [2025-11-25] AWS CloudFormation Template Reference (https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-template-resource-type-ref.html) — comprehensive documentation listing all available resource types and their properties for use in CloudFormation/SAM templates (e.g., `AWS::S3::Bucket`, `AWS::Lambda::Function`, `AWS::DynamoDB::Table`)
- [2025-11-25] CloudFormation pseudo parameters (https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html) — built-in runtime values provided by CloudFormation about deployment context, used with `!Sub` or `!Ref`: `${AWS::AccountId}`, `${AWS::Region}`, `${AWS::StackName}`, `${AWS::StackId}`, `${AWS::Partition}`, `${AWS::URLSuffix}`. Pattern is `AWS::<ParameterName>` (not service-specific like resource types)
- [2025-11-25] CloudFormation resource structure: all configurable properties go inside `Properties:` block. Only these keys can be at the same level as `Properties:`: `Type` (required), `DependsOn`, `Condition`, `DeletionPolicy`, `UpdateReplacePolicy`, `Metadata`. Everything else (BucketName, CorsConfiguration, etc.) must be nested under `Properties:`
- [2025-11-25] API Gateway Lambda Proxy Integration response format (https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-output-format) — Lambda must return dict with: `statusCode` (required, int/string), `body` (required, must be STRING - use `json.dumps()` for JSON), `headers` (optional, dict), `isBase64Encoded` (optional, bool for binary). Common mistake: returning dict in body instead of stringified JSON
- [2025-11-25] SAM Policy Templates (https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-template-list.html) — pre-built IAM policy shortcuts for common permissions in SAM templates. Examples: `S3WritePolicy` (s3:PutObject, etc.), `S3ReadPolicy`, `DynamoDBCrudPolicy`, `SQSSendMessagePolicy`. Alternative to writing full IAM policies manually. Use in `Policies:` section of Lambda function
- [2025-11-25] S3 Server-Side Encryption (SSE) types: **SSE-S3 (AES256)** — AWS manages keys, simplest, free; **SSE-KMS** — you control keys via KMS, auditable, costs per request, needed for compliance/key rotation auditing; **SSE-C** — you provide encryption keys per request, rare. Most apps use SSE-S3
- [2025-11-25] CloudFormation modifies S3 buckets in-place when updating properties (versioning, encryption, public access blocks) — does not delete/recreate the bucket, so existing objects are preserved. Only certain property changes force replacement (e.g., changing BucketName)
- [2025-11-25] Verify S3 bucket configuration with AWS CLI: `aws s3api get-bucket-versioning --bucket <name>` (check versioning status), `aws s3api get-bucket-encryption --bucket <name>` (check encryption settings - SSEAlgorithm, BucketKeyEnabled), `aws s3api get-public-access-block --bucket <name>` (check public access blocks - BlockPublicAcls, IgnorePublicAcls, BlockPublicPolicy, RestrictPublicBuckets)
- [2025-11-26] DynamoDB table key terminology: **HASH key** and **partition key** are identical (HASH is old/technical term, partition key is modern/friendly term). **RANGE key** and **sort key** are identical (RANGE is old/technical term, sort key is modern/friendly term). CloudFormation uses `KeyType: HASH` and `KeyType: RANGE`, while AWS Console and modern docs say "partition key" and "sort key" — they're the same concepts with different names for historical reasons
- [2025-11-26] YAML string quoting in CloudFormation/SAM templates is optional for simple strings — `AttributeName: userId` and `AttributeName: 'userId'` are identical, both work. Quotes are commonly used in AWS examples for clarity but are not required for alphanumeric values without special characters
- [2025-11-26] boto3 DynamoDB APIs: **Client API** (`boto3.client('dynamodb')`) is low-level with explicit type descriptors (e.g., `{'S': 'value'}` for strings, `{'N': '123'}` for numbers) — verbose but gives full control. **Resource API** (`boto3.resource('dynamodb')`) is high-level with automatic type conversion (e.g., just `'value'` and `123`) — cleaner and preferred for most use cases. Production code typically uses Resource API for simplicity
- [2025-11-26] `aws cloudformation describe-stacks --stack-name <name>` returns stack details including Outputs section — scripts use this to programmatically discover resource values (API URLs, bucket names, etc.) that were exported via CloudFormation Outputs. Query specific output: `--query 'Stacks[0].Outputs[?OutputKey==\`KeyName\`].OutputValue' --output text`
- [2025-11-26] CloudFormation Outputs serve three purposes: (1) Display values after deployment for humans to see, (2) Cross-stack references using `Export` and `!ImportValue` for stack-to-stack communication, (3) Programmatic access via `describe-stacks` API for scripts/tools to discover resource values. Outputs are infrastructure's "public API" — they define what your stack returns to the outside world
- [2025-11-26] CloudFormation Outputs enable modular infrastructure via cross-stack integration — a "shared services" stack can export VPC IDs, database endpoints, and SNS topics that 10+ application stacks import using `!ImportValue`. This decouples infrastructure: you can modify the shared services stack (e.g., change VPC configuration) without touching application stacks, as long as the exported Output names remain the same. Like a function's return value, Outputs define the stack's contract with consumers
- [2025-11-26] Lambda Layers (`AWS::Serverless::LayerVersion` or `AWS::Lambda::LayerVersion`) allow sharing dependencies across multiple Lambda functions — instead of packaging the same libraries (e.g., `requests`, `numpy`) in each function's deployment package, create a Layer once and reference it in multiple functions via `Layers: [!Ref MyLayer]`. Reduces deployment package size and enables centralized dependency management. Use for shared dependencies across multiple functions, not for single-function dependencies (use `requirements.txt` instead)
- [2025-11-26] `aws cloudformation describe-stacks --stack-name <name>` returns high-level stack information (status, outputs, parameters), while `aws cloudformation describe-stack-resources --stack-name <name>` returns details about individual resources within the stack (Lambda ARNs, S3 bucket names, DynamoDB table names, etc.). Use describe-stacks for stack-level info and outputs, describe-stack-resources to inspect specific resources created by the stack

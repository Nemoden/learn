- [2025-11-23] `aws sts get-caller-identity` returns your AWS identity info (Account ID, UserId, ARN) - useful for verifying which AWS credentials/profile you're currently using
- [2025-11-23] SAM CLI (`aws-sam-cli`) is a separate tool from AWS CLI - it's AWS's framework for building/deploying serverless apps with Infrastructure as Code (compiles to CloudFormation). Install via `brew install aws-sam-cli` or add to Nix flake
- [2025-11-23] To configure AWS credentials for a specific profile, use `aws configure --profile <profile-name>` — without `--profile`, it overwrites the `default` profile. Credentials stored in `~/.aws/credentials`, each profile has its own Access Key ID and Secret Access Key
- [2025-11-23] SAM local Lambda runs in Docker containers but can't reach localhost services directly — use `host.docker.internal` as the hostname in endpoint URLs (e.g., `http://host.docker.internal:8000` for DynamoDB Local). Pass endpoints via `--env-vars env.json`, then use `endpoint_url=os.getenv('DYNAMODB_ENDPOINT')` in boto3 client/resource calls
- [2025-11-23] `sam deploy` requires an S3 bucket to upload packaged Lambda code/dependencies before deploying — use `sam deploy --guided` on first deploy to configure bucket (saved to `samconfig.toml`), or specify `--s3-bucket <bucket-name>` manually. SAM automatically creates deployment artifacts and uploads to S3 during deploy
- [2025-11-23] `sam build` creates `.aws-sam/` directory containing built Lambda artifacts (dependencies, compiled code) — add this to `.gitignore` as it's generated output that shouldn't be committed to version control
- [2025-11-23] SAM deploys to the AWS region from your CLI configuration (check with `aws configure get region --profile <profile-name>`) — override with `sam deploy --region <region>` or set in `samconfig.toml`. All resources (Lambda, API Gateway, etc.) are created in this region
- [2025-11-23] `sam deploy --guided` prompts for configuration (stack name, region, S3 bucket, etc.) and saves choices to `samconfig.toml` — subsequent `sam deploy` commands read from this file automatically, so you don't need to specify parameters again. Commit `samconfig.toml` to git for team consistency
- [2025-11-23] SAM automatically creates all required infrastructure: when you define an `AWS::Serverless::Function` with API events, `sam deploy` creates the Lambda function, API Gateway REST API, execution IAM role with CloudWatch Logs permissions, and CloudWatch log group — you don't manually create these supporting resources
- [2025-11-23] SAM templates can mix SAM-specific resources (`AWS::Serverless::Function`, `AWS::Serverless::Api`, etc.) with standard CloudFormation resources (`AWS::S3::Bucket`, `AWS::DynamoDB::Table`, etc.) in the same `template.yaml` — SAM is syntactic sugar on top of CloudFormation, not a replacement. Use SAM resources for serverless components, CFN resources for everything else
- [2025-11-24] CloudFormation's `DeletionPolicy: Retain` only protects resources when you delete the stack, not during drift correction — manual changes still get overwritten on next deploy
- [2025-11-25] `sam build --use-container` runs the build inside a Docker container with Python + pip pre-configured (AWS provides official runtime images) — use when local Python environment lacks pip or has dependency conflicts. This mirrors Lambda's actual execution environment more closely than local builds
- [2025-11-25] `samconfig.toml` can have multiple named configuration sections (e.g., `[default]`, `[production]`) — `sam deploy` uses `[default]` by default, use `sam deploy --config-env production` to deploy with a different configuration section. Each section can have different stack names, regions, and deployment parameters
- [2025-11-25] SAM automatically creates a managed S3 bucket for deployment artifacts (Lambda code packages, CloudFormation templates) — you can specify a different bucket in `samconfig.toml` or set `resolve_s3=False` to disable automatic bucket creation and use a manually specified bucket instead
- [2025-11-25] IaC tools (SAM, Terraform, CDK) often need permanent credentials or explicit session handling (temporary/SSO credentials can cause "unable to locate credentials" errors) — production solutions: CI/CD pipelines using IAM roles (no keys needed), AWS SSO with proper SDK configuration, or short-lived credentials via STS assume-role
- [2025-11-25] Lambda has two distinct permission types: (1) **Execution Role (IAM Role)** — defines what Lambda can do (access S3, DynamoDB, SES, etc.), created as `HelloWorldFunctionRole`; (2) **Invoke Permission (Lambda Permission)** — defines who can call Lambda (API Gateway, S3 events, CLI, etc.), created as resource-based policy like `HelloWorldPermissionProd`. Execution role = Lambda's capabilities, Invoke permission = Lambda's callers
- [2025-11-25] Lambda has a 512MB ephemeral disk limit (`/tmp` directory) and storage is destroyed after execution — for persistent file storage, use S3 instead. Lambda is designed for compute, not storage
- [2025-11-25] API Gateway has a 10MB payload limit — you can't upload large files through API Gateway/Lambda. Solution: use S3 presigned URLs where client uploads directly to S3, bypassing API Gateway entirely
- [2025-11-25] AWS CloudFormation Template Reference (https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-template-resource-type-ref.html) — comprehensive documentation listing all available resource types and their properties for use in CloudFormation/SAM templates (e.g., `AWS::S3::Bucket`, `AWS::Lambda::Function`, `AWS::DynamoDB::Table`)
- [2025-11-25] CloudFormation pseudo parameters (https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html) — built-in runtime values provided by CloudFormation about deployment context, used with `!Sub` or `!Ref`: `${AWS::AccountId}`, `${AWS::Region}`, `${AWS::StackName}`, `${AWS::StackId}`, `${AWS::Partition}`, `${AWS::URLSuffix}`. Pattern is `AWS::<ParameterName>` (not service-specific like resource types)
- [2025-11-25] CloudFormation resource structure: all configurable properties go inside `Properties:` block. Only these keys can be at the same level as `Properties:`: `Type` (required), `DependsOn`, `Condition`, `DeletionPolicy`, `UpdateReplacePolicy`, `Metadata`. Everything else (BucketName, CorsConfiguration, etc.) must be nested under `Properties:`
- [2025-11-25] API Gateway Lambda Proxy Integration response format (https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-output-format) — Lambda must return dict with: `statusCode` (required, int/string), `body` (required, must be STRING - use `json.dumps()` for JSON), `headers` (optional, dict), `isBase64Encoded` (optional, bool for binary). Common mistake: returning dict in body instead of stringified JSON
- [2025-11-25] SAM Policy Templates (https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-template-list.html) — pre-built IAM policy shortcuts for common permissions in SAM templates. Examples: `S3WritePolicy` (s3:PutObject, etc.), `S3ReadPolicy`, `DynamoDBCrudPolicy`, `SQSSendMessagePolicy`. Alternative to writing full IAM policies manually. Use in `Policies:` section of Lambda function
- [2025-11-25] S3 Server-Side Encryption (SSE) types: **SSE-S3 (AES256)** — AWS manages keys, simplest, free; **SSE-KMS** — you control keys via KMS, auditable, costs per request, needed for compliance/key rotation auditing; **SSE-C** — you provide encryption keys per request, rare. Most apps use SSE-S3
- [2025-11-25] CloudFormation modifies S3 buckets in-place when updating properties (versioning, encryption, public access blocks) — does not delete/recreate the bucket, so existing objects are preserved. Only certain property changes force replacement (e.g., changing BucketName)
- [2025-11-25] Verify S3 bucket configuration with AWS CLI: `aws s3api get-bucket-versioning --bucket <name>` (check versioning status), `aws s3api get-bucket-encryption --bucket <name>` (check encryption settings - SSEAlgorithm, BucketKeyEnabled), `aws s3api get-public-access-block --bucket <name>` (check public access blocks - BlockPublicAcls, IgnorePublicAcls, BlockPublicPolicy, RestrictPublicBuckets)
